#* C++(python 以外)のgtpボット用設定

#* オンラインサーバー上でのランニング、または実際のトーナメントや試合でのランニング:
#* その予定のある方は、コミ・置き碁の適切な取り扱いや試合終了後のクリーンアップなど、
#* 様々な詳細について、下記の「ルール」をよく読んでおくと良いでしょう。

#* パフォーマンスとメモリ使用量に関する注意事項:
#* 以下のいずれかを調整する必要がある場合があります:

#* numSearchThreads:
#* 使用するCPUスレッド数です。
#* GPUが強力な場合、GPUを有効に活用するためには大規模なバッチを供給するために多くのスレッドが
#* 必要になるため、実際にはプロセッサのコア数よりもはるかに高くなる可能性があります。
#* "./katago benchmark "コマンドは、このパラメータを調整したり、以下の他のパラメータを
#* 変更した場合の効果をテストしたりするのに役立ちます!

#* nnCacheSizePowerOfTwo:
#* これは、主にRAMおよびメモリを使用するNNキャッシュのサイズを制御します。
#* メモリ使用量を気にせず、数万回以上の訪問がある検索のパフォーマンスを向上させたい場合は、
#* この値を大きくしてください。メモリ使用量を制限したい場合は、この値を下げてください。
#* ニューラルネットの各エントリは約1.5KBかかりますが、ボード全体の所有権/地の可視化を
#* 使用する場合を除いて、各エントリは約3KBかかります。
#* エントリ数は(2 ** nnCacheSizePowerOfTwo)です。
#* 例 2 ** 18 = 262144.

#* その他の注意事項:
#* 複数のGPUをお持ちの方は、下記の「OpenCL GPUの設定」または「CUDA GPUの設定」をご覧ください。
#* OpenCLを使用している場合は、KataGoが正しいデバイスを選択していることを確認したいでしょう!
#* (例えば、システムによってはIntel CPU OpenCLとGPU OpenCLの両方を持っている場合がありますが、
#* KataGoが間違った方を選んでいるように見える場合は、以下の "openclDeviceToUse" を指定することで
#* 修正します)

#* また、"maxVisits"、"ponderingEnabled"、"resignThreshold" などのパラメータは、
#* 使用目的に応じて調整するとよいでしょう。

#* ----------------------------------------------------------------------------------------
#* `katago gtp` コマンドでは、コマンドライン引数で必要に応じて以下のすべての値を設定
#* または上書きすることができます:
#* -override-config KEY=VALUE,KEY=VALUE,...

#* モデル ---------------------------------------------------------------------------------
modelFile = kata1-b40c256-s11840935168-d2898845681.bin.gz
#modelFile = g170e-b10c128-s1141046784-d204142634.bin.gz
#modelFile = g170e-b15c192-s1672170752-d466197061.bin.gz
#modelFile = g170e-b20c256x2-s5303129600-d1228401921.bin.gz

#* ログ -----------------------------------------------------------------------------------


#* ログの出力先は？
#logDir = gtp_logs  # KataGo の各実行は、このディレクトリ内の個別のファイルに記録されます
logFile = gtp.log  # logDir の代わりにこれを使用して、単一のファイルを直接指定します

#* ロギングのオプション
#logAllGTPCommunication = true
logAllGTPCommunication = false
#logSearchInfo = true
logSearchInfo = false
#logToStderr = true
logToStderr = false

#* KataGoはGTP起動時に標準エラーにいくつかの情報を表示します。
#* これをコメント解除すると、それを抑制し、沈黙を保つことができます。
#* startupPrintMessageToStderr = false
startupPrintMessageToStderr = false

#* 標準エラーに何かをチャットして、OGSのマルコビッチチャットのようなものに使う。
#* ogsChatToStderr = true

#* オプションで、KataGoがopenCLTunerファイルやその他のキャッシュデータなどを
#* 保存しようとする場所を "DIRECTORY" で上書きします。
# homeDataDir = DIRECTORY

#* 分析 -----------------------------------------------------------------------------------

#* lz-analyzeなどで出力される分析の最大長を設定します。
#* バリエーションの最初の手の後の手の数を制御します。
# analysisPVLen = 15

#* チャットや分析の勝率を(BLACK|WHITE|SIDETOMOVE)として報告します。
#* デフォルトは SIDETOMOVE で、これは LZ を使用しているツールが期待しているものです。
# reportAnalysisWinratesAs = SIDETOMOVE

#* コメントを外して正の値に設定することで、KataGoが最初の手をより深く正確に探索しますが、
#* 分析のために、より多様な手を探索し、評価を与えるようにします(対局には影響しません)。
#* 0.03や0.06のような値にすると、さまざまな穏やかな、しかしそれでも目立って検索範囲が
#* 広がります。1 のような極端な値は、非常に悪い手であっても、
#* 碁盤上のすべての手に多くのプレイアウトを分配します。
# analysisWideRootNoise = 0.04

#* デフォルトのルール ----------------------------------------------------------------------
#* ルールの説明は https://lightvector.github.io/KataGo/rules.html を参照してください。
#* これらのルールはデフォルトであり、いくつかのカスタムGTPコマンドで実行中に変更することができます。
#* そのようなコマンドは https://github.com/lightvector/KataGo/blob/master/docs/GTP_Extensions.md
#* を参照してください。

#* 設定できるルール:
#*   "tromp-taylor", "tromp_taylor", "tromp taylor", "tromptaylor"
#*   "chinese"
#*   "chineseogs", "chinese_ogs", "chinese-ogs"
#*   "chinesekgs", "chinese_kgs", "chinese-kgs"
#*   "japanese"
#*   "korean"
#*   "aga"
#*   "agabutton", "aga-button", "aga_button", "aga button"
#*   "bga"
#*   "french"
#*   "ancientarea", "ancient-are", "ancient_area", "ancient area"
#*   "ancientterritory", "ancient-territory", "ancient_territory", "ancient territory"
#*   "stonescoring", "stone-scoring", "stone_scoring", "stone scoring"
#*   "nz", "newzealand", "new zealand", "new-zealand, "new_zealand"
#*   "goe"
#*   "ing"

#* KataGoは、特定の人間のルールセットに完全に一致するとは主張しませんが、
#* KataGoは、実装されたルールに可能な限り近づけてプレイしようとします。
#rules = tromp-taylor
rules = chinese

#* 個々のルールの任意の組み合わせを指定する場合は、代わりに以下を使用してください。

# koRule = SIMPLE       # シンプルな劫ルール (三劫 = 無勝負)
# koRule = POSITIONAL   # 位置的スーパー劫
# koRule = SITUATIONAL  # 状況的スーパー劫

# scoringRule = AREA       # 生き石と地の数の合計:実戦解決
# scoringRule = TERRITORY  # 生きている地の数のみ:死活判定 (コンピュータに優しい特別な地のルールセット)

# taxRule = NONE  # 囲まれた全ての空点を得点化
# taxRule = SEKI  # セキの目はポイントにカウントされません
# taxRule = ALL   # 生きるために必要な2眼には、すべてのグループに2つのポイント

# multiStoneSuicideLegal = true   # 多石自殺手は合法なのか？(一石自殺手は常に違法)

# hasButton = false # 最初のパスに0.5点を付与するエリアスコアリング時にtrueに設定

# friendlyPassOk = true  # パス前に石を捕獲する必要があるコンピューターのルールセットを除きtrueに設定

# whiteHandicapBonus = 0    # 黒の置き石に白のポイントを与えない (Tromp-taylor, NZ, JP)
# whiteHandicapBonus = N-1  # 黒の置き石に白の N-1 ポイントを与える (AGA)
# whiteHandicapBonus = N    # 黒の置き石に白の N ポイントを与える (Chinese)

#* GTPで指定していない場合、デフォルトで起動時にKataGoが使用するボードサイズを調整するために、
#* コメントを外して変更します。
# defaultBoardSize = 19

# GUIまたはGTP コントローラーが別のコミを設定しようとした場合でも特定のコミを強制するにはこれを指定します
# ignoreGTPAndForceKomi = 7

#* ボットの動作 ----------------------------------------------------------------------------

#* 投了 -------------

#* 少なくとも一連の resignConsecTurns において、winLossUtility (これは [-1,1] スケール) が
#* resignThreshold を下回った場合に、投了が発生します。
allowResignation = true
resignThreshold = -0.90
resignConsecTurns = 3

#* このポイントより少ない状態で、ゲームを投了しないようにコメントを外して変更します。
# resignMinScoreDifference = 10

#* 置き碁 -------------

#* 開始直後に黒が連続して何手も打った場合は、置き碁の対局になると仮定します。
#* これは、いくつかのサーバーやいくつかのGUIに必要であり、また、多くのSGFファイルから初期化
#* するときに、GTP "place_free_handicap" コマンドではなく、黒石のために繰り返しGTP "play "
#* コマンドを使用して置き碁の対局を設定する可能性があります。
#* しかし、whiteHandicapBonus を使用していて、そのような訓練をしていないサーバーがある場合、
#* それはまた、コミの誤った理解につながる可能性があります。
#* デフォルトは trueです! この動作を無効にするには、コメントを付けずに false に設定します。
# assumeMultipleStartingBlackMovesAreHandicap = true

#* katagoを動的に置き碁または変更されたコミのゲームで、それらのゲーム設定に基づいて
#* 相手よりも強いか弱いと仮定するように調整し、ハンディキャップの強さを大幅に向上させますが、
#* 勝率とスコアを偏らせることができます。
#* Lizzie のようなプログラムで使用される分析 (lz-analyze, kata-analyze) には影響を与えないので、
#* 分析は偏り(バイアス)がないままです。
#* コメントを外してこれを 0 に設定すると、無効になり、KataGoが常に同じプレイをするようになります。
# dynamicPlayoutDoublingAdvantageCapPerOppLead = 0.045

#* 動的レベルの代わりに、このコメントを外して-3.0から3.0までの値に設定することで、
#* KataGoの攻撃性をFIXEDレベルに設定することができます。
#* 分析ツールに影響を与えます (Lizzie のようなプログラムで使用される lz-analyze, kata-analyze)。
#* 負の値を指定すると、KataGoが相手よりもはるかに弱いかのように振る舞うようにし、
#* 防御的な手を好むようにします。
#* 正の値を指定すると、KataGoを相手よりもはるかに強いかのように振る舞わせ、積極的に
#* プレイすることを好むか、あるいはわずかにオーバープレイすることを好むようにします。
#* この値と「dingamicanPrayoutDoublingAndAdvantageCapPerOppLead」の両方が設定されている場合は、
#* すべてのゲームでdynamicが使用され、分析ツールではこの固定値が使用されます。
# playoutDoublingAdvantage = 0.0

#* これらのうちの1つをコメント解除することで、固定プレイアウトの倍増しアドバンテージは、
#* KataGoが指定された色の石をプレイしているときにのみ適用され、反対色をプレイしているときには
#* 無効になります。
# playoutDoublingAdvantagePla = BLACK
# playoutDoublingAdvantagePla = WHITE

#* パスとクリーンアップ -------------

#* パスがTromp-Taylorルールの下で終了して「勝つ」場合でも、ボットがそのパスによってゲームが
#* 終了するとは決して想定しないでください。
#* 通常は、分析に使ったり、スコアリングがTromp-Taylorルール以外で実装されている可能性のある
#* サーバーでプレイする場合は、これが良いと思います。
#* デフォルトはtrueです! これを無効にするには、コメントを外してfalseに設定します。
# conservativePass = true

#* 地のスコアリングを使用する場合、セルフプレーゲームは、人間のプレイヤーにとっては
#* 混乱を招く可能性がある特別なクリーンアップルールを使用して、2つのパスを超えて続行されます。
#* このオプションは、GTPプレイのためにボットを使用しているときに、
#* 特別なクリーンアップフェーズに到達できないようにします。
#* デフォルトはtrueです! KataGoで特別なクリーンアップを開始できるようにするには、
#* コメントを外してfalseに設定します。
#* 例えば、それ自体や、https://lightvector.github.io/KataGo/rules.html
#* で文書化されたルールを正確に実装した別のボットに対してテストする場合
# preventCleanupPhase = true

#* その他の動作 --------------------

#* ボードが左右対称の場合は、同等の手のコピーをひとつだけ検索します。
#* 劫やスーパー劫も考慮しようとしても、理論的にはスーパー劫には完全ではありません。
#* これを無効にするには、コメントを外して false に設定します。
# rootSymmetryPruning = true

#* コメントを外して、KataGoがKataGoネットの一部が誤評価する特定の定石を回避し、
#* また、それを常にプレイするのが好きな他のいくつかの特定のボットに対して、
#* 布石の多様性を向上させるためにtrueに設定します。

# avoidMYTDaggerHack = false

#* KataGoに、ボードの隅々まで同じ定石をプレイすることをやや避けるように指示します。
#* 特定の値に設定するには、コメントを外します。
#* それ以外の場合、偶数ゲームでは 0 に、置き碁では 0.005 にデフォルト設定されます。
#* この構成の下部にある回避 SGF メカニズムも参照してください。
# avoidRepeatedPatternUtility = 0.0

#* 不利なコミでもKataGoをマネ碁で少し戦わせるための実験的ロジック。
#* GTP 対局ではデフォルトで有効化され、GTP 分析 (つまり、lizzie) と分析エンジンでは無効化されています。
#* コメントを外し、true に設定して分析を有効にするか、false に設定して完全に無効にします。
# antiMirror = true

#* 検索制限 -----------------------------------------------------------------------------------

#* "maxVisits"、"maxPlayouts"、"maxTime"のすべてにおいて、検索はGTPの時間制御に従おうとし、
#* もしGTPが現在のゲームでも時計の下でプレイしていると伝えれば、指定された最大値よりも速く
#* 手を動かすかもしれません。

#* 提供されている場合は、1回の検索でのルート訪問数の最大値をこの程度に制限してください。
#* (ツリーの再利用では、以前の検索での訪問もカウントされます)
# maxVisits = 500
#maxVisits = 0
#* 提供されている場合は、1回の検索あたりの新規プレイアウトの最大数をこれだけに制限してください。
#* (ツリーの再利用では、プレイアウトは以前の検索にはカウントされません)
# maxPlayouts = 300
#maxPlayouts = 1
#* 提供されている場合、この秒数で検索時間を制限します。
# maxTime = 10

#* 対局相手の次の手について熟考しますか？
ponderingEnabled = false
maxTimePondering = 60  # 熟考するまでの最大時間(秒単位)。コメントアウトして無制限にします。
#* 注: "maxVisitsPondering"または"maxPlayoutsPondering"も設定できます。

#* GTPタイムコントロールのラグのためにバッファリングする秒数
#* - 移動毎にこれだけのラグがあると仮定して、少し速く着手します。
lagBuffer = 1.0

#* 検索で使用するスレッドの数
numSearchThreads = 5

#* 相手がパスしている場合は、親しみを持たせるために少し速く着手します。
searchFactorAfterOnePass = 0.50
searchFactorAfterTwoPass = 0.25
#* 親しみやすさのために、大差の勝利の場合は少し速くプレイしてください
searchFactorWhenWinning = 0.40
searchFactorWhenWinningThreshold = 0.95

#* GPU設定 -------------------------------------------------------------------------------

#* 単一のGPUに一度に送信するポジションの最大数。
#* ここでのデフォルト値はnumSearchThreadsとほぼ同じですが、メモリが不足している場合や、
#* 複数のGPUを使用していて作業を分割することを想定している場合は、手動で指定することができます。
# nnMaxBatchSize = <integer>

#* ツリー内の転置の場合には、多数のニューラルネット評価(2 **この値)をキャッシュします。
#* KataGoのRAM使用量の主要な構成要素を調整したい場合はコメントを解除し、編集を変更します。
# nnCacheSizePowerOfTwo = 20

#* nnCacheのミューテックスプールのサイズは(2 **この値)です。
# nnMutexPoolSizePowerOfTwo = 16

#* ニューラルネットの検証を実行する際にボードの向きをランダムにしますか？
#* コメントを外し、falseに設定すると無効になります。
# nnRandomize = true
#* 指定された場合、ランダム化の代わりに特定のシードを nnRandomize に強制的に使用します。
# nnRandSeed = abcdefg

#* 複数のGPUを使用するには:
#* これを、使用するGPUの数に設定します。
#* 1以上の場合は、以下の適切なCUDAまたはOpenCLセクションのコメントを外してください。
# numNNServerThreadsPerModel = 1

#* TENSORRT GPUの設定 --------------------------------------
#* これらは KataGo の TENSORRT バージョンを使用する場合にのみ適用されます。

#* ひとつの GPU を使用している場合:
#* 使用する GPU がデバイス 0 ではないことが判明した場合は、オプションでコメントを外して変更します。
# trtDeviceToUse = 0

#* ふたつの GPU を使用している場合:
#* 次の 2行のコメントを外します (さらに、上記の numNNServerThreadsPerModel を設定します):
# trtDeviceToUseThread0 = 0  # 使用する 1番目のGPUがデバイス0ではないことが判明した場合はこれを変更します。
# trtDeviceToUseThread1 = 1  # 使用する 2番目のGPUがデバイス1ではないことが判明した場合はこれを変更します。

#* 3つの GPU を使用している場合:
#* 次の 3行のコメントを外します (さらに、上記の numNNServerThreadsPerModel を設定します):
# trtDeviceToUseThread0 = 0  # 使用する 1番目のGPUがデバイス0ではないことが判明した場合はこれを変更します。
# trtDeviceToUseThread1 = 1  # 使用する 2番目のGPUがデバイス1ではないことが判明した場合はこれを変更します。
# trtDeviceToUseThread2 = 2  # 使用する 3番目のGPUがデバイス2ではないことが判明した場合はこれを変更します。

#* 4つ、5つなど複数のGPUを持っていれば、そのパターンが推測できるでしょう。

#* CUDA GPUの設定 --------------------------------------
#* これらは KataGo の CUDAバージョンを使用する場合にのみ適用されます。

#* ひとつの GPU を使用している場合:
#* 使用する GPU がデバイス 0 ではないことが判明した場合は、オプションでコメントを外して変更します。
# cudaDeviceToUse = 0

#* ふたつの GPU を使用している場合:
#* 次の 2行のコメントを外します (さらに、上記の numNNServerThreadsPerModel を設定します):
# cudaDeviceToUseThread0 = 0  # 使用する 1番目のGPUがデバイス0ではないことが判明した場合はこれを変更します。
# cudaDeviceToUseThread1 = 1  # 使用する 2番目のGPUがデバイス1ではないことが判明した場合はこれを変更します。

#* 3つの GPU を使用している場合:
#* 次の 3行のコメントを外します (さらに、上記の numNNServerThreadsPerModel を設定します):
# cudaDeviceToUseThread0 = 0  # 使用する 1番目のGPUがデバイス0ではないことが判明した場合はこれを変更します。
# cudaDeviceToUseThread1 = 1  # 使用する 2番目のGPUがデバイス1ではないことが判明した場合はこれを変更します。
# cudaDeviceToUseThread2 = 2  # 使用する 3番目のGPUがデバイス2ではないことが判明した場合はこれを変更します。

#* 4つ、5つなど複数のGPUを持っていれば、そのパターンが推測できるでしょう。

#* KataGoは、FP16を自動的に使用するか、NVIDIA GPUの計算能力に基づいていません。
#* 特定の動作を強制したい場合は、これらの行のコメントを外して、"true "または "false "に
#* 変更することができます。例えば、FP16を使用しているが、あなたのグラフィックカードではエラーが
#* 発生している、あるいはFP16を使用していないが、使用すべきだと思っているなどです。
# cudaUseFP16 = auto
# cudaUseNHWC = auto

#* OpenCL GPUの設定 --------------------------------------
#* これらは KataGo の OpenCLバージョンを使用する場合にのみ適用されます。
#* 可能な最大サイズだけでなく、ボードサイズ毎にOpenCLを個別に調整するコメントを外します。
# openclReTunePerBoardSize = true

#* ひとつの GPU を使用する場合:
#* オプションでコメントを外し、使用する最適なデバイスが間違って推測された場合はこれを変更します。
#* デフォルトの動作は、使用するシステム上の「最良の」GPUまたはデバイスを推測しようとしますが、
#* 通常は適切な推測になります。
# openclDeviceToUse = 0

#* ふたつの GPU を使用する場合:
#* 次の 2行のコメントを外し、XとYを使用したいデバイスのデバイスIDに置き換えてください。
#* 0や1ではないかもしれませんが、コンピュータの中にはOpenCLのデバイスをたくさん持っているものもあります。
#* KataGoを起動すると、デバイスが何であるかを見ることができます。
#* (また、上記の numNNServerThreadsPerModel を設定します。)
# openclDeviceToUseThread0 = X
# openclDeviceToUseThread1 = Y

#* 3つの GPU を使用する場合:
#* 次の 3行のコメントを外し、XとYとZを使用したいデバイスのデバイスIDに置き換えてください。
#* 0や1や2ではないかもしれませんが、コンピュータの中にはOpenCLのデバイスをたくさん持っているものもあります。
#* KataGoを起動すると、デバイスが何であるかを見ることができます。
#* (また、上記の numNNServerThreadsPerModel を設定します。)
# openclDeviceToUseThread0 = X
# openclDeviceToUseThread1 = Y
# openclDeviceToUseThread2 = Z

#* 4つ、5つなど複数のGPUを持っていれば、そのパターンが推測できるでしょう。

#* KataGo はチューニング中のGPUテストに基づいて、自動的に FP16 を使用するかどうかを決定します。
#* 特定の動作を強制したい場合は、これらの行のコメントを外して、"true "または "false "に
#* これはかなり単純な設定です。
#* さまざまな引数を指定してチューナを再実行することで、より詳細な設定をテストできます。
# openclUseFP16 = auto

# Eigen-specific の設定 --------------------------------------
# これらは KataGo の Eigen (純粋な CPU) バージョンを使用する場合にのみ適用されます。

# これは、Eigen バックエンドでニューラル ネットワークを評価するための CPU スレッドの数です。
# デフォルトは numSearchThreads です。
# numEigenThreadsPerModel = X

#* ルート移動の選択とバイアス -------------------------------------------------------------
#* 以下の値のコメントを外して編集し、デフォルトから変更します。

#* 指定されている場合は、ランダムにではなく、検索の様々なものに特定のシードを強制的に使用します。
# searchRandSeed = hijklmn

#* 対局序盤の温度、この温度で選ばれた手の間をランダムにします。
# chosenMoveTemperatureEarly = 0.5
#* 対局序盤の温度は、これだけの手を打つたびに0.5度ずつ減衰し、碁盤の大きさに応じて変化します。
# chosenMoveTemperatureHalflife = 19
#* 対局序盤の探索終了時には、この温度で選択された手の間でランダム化します。
# chosenMoveTemperature = 0.10
#* chosenMoveTemperature を適用する前に、(すべての移動の訪問が少なすぎる場合を除く)
#* 可能性の低い各指し手からこの訪問回数を差し引きます。
# chosenMoveSubtract = 0
#* chosenMoveSubtract と同じですが、閾値以下の手だけを剪定し、閾値以上の手には影響しません。
# chosenMovePrune = 1

#* サンプリングする対称性の数(置換を含む)とルートでの平均値
# rootNumSymmetriesToSample = 1

#* 指し手選択のためのLCBを使用していますか?
# useLcbForSelection = true
#* 他のものよりも優れた指し手のLCBの選択のための標準偏差を指定します。
# lcbStdevs = 5.0
#* 指し手がこの割合の訪問を最上位の指し手とする場合にのみLCBオーバーライドを使用します。
# minVisitPropForLCB = 0.15

#* 内部パラメータ ------------------------------------------------------------------------------
#* 以下の値のコメントを外して編集し、デフォルトから変更します。

#* 勝敗判定の効用値(ユーティリティ)をスケーリングします。
# winLossUtilityFactor = 1.0
#* スコアを最大化しようとする効用値(ユーティリティ)をスケーリングします。
# staticScoreUtilityFactor = 0.10
# dynamicScoreUtilityFactor = 0.30
#* 動的に中央スコアを調整して、この割合をゼロに向かって、合理的な値で上限を設定します。
# dynamicScoreCenterZeroWeight = 0.20
# dynamicScoreCenterScale = 0.75
#* 三劫などの長いサイクルが原因で「勝負がつかない」ことがある場合、
#* スーパー劫ではないルールセットでの効用値(-1から1)
# noResultUtilityForWhite = 0.0
#* 白の場合、引き分けをカウントする勝ち数(0から1)
# drawEquivalentWinsForWhite = 0.5

#* MCTSのための探査定数
# cpuctExploration = 1.0
# cpuctExplorationLog = 0.45

#* 不安定な位置でより多くの探索を制御し、安定した位置でより少ない探索を制御するパラメータ。
# cpuctUtilityStdevPrior = 0.40
# cpuctUtilityStdevPriorWeight = 2.0
# cpuctUtilityStdevScale = 0.85

#* MCTSのためのFPU削減定数
# fpuReductionMax = 0.2
# rootFpuReductionMax = 0.1
# fpuParentWeightByVisitedPolicy = true

#* ネット自身の自己報告された不確実性に基づいて評価の重み付けを制御するパラメータ。
# useUncertainty = true
# uncertaintyExponent = 1.0
# uncertaintyCoeff = 0.25

#* 非常に悪いバリューを持つ子ノードを、良い子ノードと比較してダウンウエイトを適用する量
# valueWeightExponent = 0.25

#* 最後にパスすること、ダメを埋めること、自分の地でプレイする時間を無駄にしないこと
#* などに関して、人間のように振る舞うようにボットにわずかなインセンティブを与え、
#* ポイントの点では同等ですが人間には少し不親切な手をプレイしないようにします。
# rootEndingBonusPoints = 0.5

#* 負けないようにゲームを長引かせているだけの無駄な手をボットに剪定させます。
# rootPruneUselessMoves = true

#* ローカル パターン キーに基づいてバイアス補正を適用する。
# subtreeValueBiasFactor = 0.45
# subtreeValueBiasWeightExponent = 0.85

#* ツリー検索ではなくグラフ検索を使用します - 転置の検索を識別して共有します。
# useGraphSearch = true

#* 検索同期のためにノード テーブルを分割する量
# nodeTableShardsPowerOfTwo = 16
#* スレッドがノードを下降するときに追加する仮想損失の数
# numVirtualLossesPerThread = 1

#* 負荷の高いマルチスレッドでの eval の品質を向上
# useNoisePruning = true

#* SGF パターンの回避 ------------------------------------------------------------------------------
#* このセクションのパラメータは、KataGo をカスタマイズして、
#* 起動時に読み込まれる一連の提供された SGF ファイルに基づいて特定のパターンに従う動きを回避するための
#* 強力な方法を提供します。
#* さらに、SGF ファイルの Move(指し手) のコメントに文字列 %SKIP% が含まれている場合、
#* その Move(指し手) はこの目的では無視されます。

#* エンジンの起動時にこのディレクトリから sgf ファイルをロードします。
#* (起動時のみ、エンジンを再起動しない限りリロードされません)。
# avoidSgfPatternDirs = path/to/directory/with/sgfs/

#* 一致する指し手ごとに、この多くの効用値(ユーティリティ)にペナルティを課します。
#* KataGo にペナルティを課す代わりに SGF パターンを優先させたい場合は、これをマイナスに設定してください!
#* この数値は大きくする必要はありません。0.001 であっても違いがあります。
#* 値が大きすぎると、再生がうまくいかない場合があります。
# avoidSgfPatternUtility = 0.001

#* オプション - 最新のこの数のファイルのみをロードします。
# avoidSgfPatternMaxFiles = 20

#* オプション - ペナルティは古い SGF ファイルごとにこれで乗算されるため、
#* 古い sgf ファイルは新しいものよりも重要ではありません。
# avoidSgfPatternLambda = 0.90

#* オプション - この名前のプレイヤーが行った指し手だけに注意してください。
#* たとえば、ボットの過去のゲームが SGF のように表示される名前に設定できます。
#* これにより、ボットは、対局相手が指した指し手ではなく、
#* 過去の対局で行った指し手の繰り返しのみを回避します。
# avoidSgfPatternAllowedNames = my-ogs-bot-name1,my-ogs-bot-name2

#* オプション - この手数より前に発生した SGF ファイル内のすべての指し手を無視します。
# avoidSgfPatternMinTurnNumber = 0

#* より多くの回避パターンについて:
# パラメータの 2番目のセット、および 2, 3, 4, ... の番号を付けて 3番目、4番目などを指定することもできます
# avoidSgf2PatternDirs = ...
# avoidSgf2PatternUtility = ...
# avoidSgf2PatternMaxFiles = ...
# avoidSgf2PatternLambda = ...
# avoidSgf2PatternAllowedNames = ...
# avoidSgf2PatternMinTurnNumber = ...
